; This module contains a minimax implementation for the tic-tac-toe game.
;
; There are functions which can map a game to a score (based on all the
; possible outcomes of that game at the current state).
;
; Other functions will simulate movements by selecting whichever move produces
; the best game.
#lang racket

(define X-symb 'X)
(define O-symb 'O)
(define tie-symb 'T)

(define X-score 100.0)
(define O-score -100.0)
(define tie-score 0.0)

; The factor by which game scores are diminished after each turn. This is
; important to make the computer attempt to win as soon as possible.
(define diminishing-factor 0.9)

(define X-selector argmax)
(define O-selector argmin)

(define lines-list (list
  ; Horizontal lines
  (list 0 1 2) (list 3 4 5) (list 6 7 8)
  ; Vertical lines
  (list 0 3 6) (list 1 4 7) (list 2 5 8)
  ; Diagonal lines
  (list 0 4 8) (list 2 4 6)))

(struct game [state] #:transparent)

; Creates and returns an empty game.
(define (make-empty-game)
  (game (make-vector 9 empty)))

; Converts a game to a human-readable string.
;
; This string has two newline characters on it.
(define (game-to-string a-game)
  (apply format "~a ~a ~a\n~a ~a ~a\n~a ~a ~a" (map (lambda (s) (if (empty? s) " " s)) (vector->list (game-state a-game)))))

; Compares two game moves to see if the first is less than the second.
(define (game-move-less-than? a b)
  (cond
    [(and (empty? a) (empty? b)) false]
    [(empty? a) true]
    [(empty? b) false]
    [else (symbol<? a b)]))

; Compares two games to see if the first is less than the second.
(define (game-less-than? a b)
  (andmap game-move-less-than? (vector->list (game-state a)) (vector->list (game-state b))))

; Counts how many times the specified symbol has played in the game.
(define (count-plays a-game symb)
  (vector-count (lambda (s) (equal? s symb)) (game-state a-game)))

; Determines the next player to play in the game.
;
; This function assumes that X always starts.
(define (determine-next-to-play a-game)
  (if (> (count-plays a-game X-symb) (count-plays a-game O-symb)) O-symb X-symb))

; Makes a copy of the input vector and replaces the element at pos by v before returning it.
(define (vector-copy-and-replace vec pos v)
  (vector-append (vector-take vec pos) (vector v) (vector-drop vec (+ pos 1))))

; Returns a copy of the game with symb at pos.
(define (game-after-replacing a-game symb pos)
  (game (vector-copy-and-replace (game-state a-game) pos symb)))

; Returns a list of games generated by replacing symb at the positions in the pos-list.
(define (list-games-after-replacing a-game symb pos-list)
  (map (lambda (i) (game-after-replacing a-game symb i)) pos-list))

; Returns a list with all the possible games a player can generate in his next move.
(define (derive-games-for-player a-game symb)
  (list-games-after-replacing a-game symb (filter (lambda (i) (empty? (vector-ref (game-state a-game) i))) (range 9))))

; Enumerates all games that may be derived from the specified game in a single turn.
(define (derive-games game)
  (derive-games-for-player game (determine-next-to-play game)))

; Checks if the positions a, b, and c of the vector are equal symbols.
(define (three-equal-symbols? a-vector a b c)
  ; Also check that these are symbols and not something else.
  (and (symbol? (vector-ref a-vector a))
       (equal? (vector-ref a-vector a) (vector-ref a-vector b))
       (equal? (vector-ref a-vector b) (vector-ref a-vector c))))

; Returns the first element of lst that is not empty or empty if such element does not exist.
(define (first-not-empty lst)
  (if (empty? lst)
    empty
    (if (empty? (first lst))
      (first-not-empty (rest lst))
      (first lst))))

; Evaluates the game for the specified list of triplets.
;
; Either returns the symbol of the outcome or empty if no one won.
(define (game-evaluate-triplets a-game triplet-list)
  (foldl
    (lambda (triplet current-result)
      (if (empty? current-result)
        ; Only try to find a new result if we did not get an equal triplet yet.
        (if (three-equal-symbols? (game-state a-game) (first triplet) (second triplet) (third triplet))
          (vector-ref (game-state a-game) (first triplet))
          empty)
        current-result))
    empty
    triplet-list))

; Evaluates the arithmetic mean of a list of numbers.
(define (list-mean list-of-numbers)
  (if (empty? list-of-numbers) 0 (/ (apply + list-of-numbers) (length list-of-numbers))))

; Evaluates the game for results in all valid directions.
;
; Either returns the symbol of the winner, the tie symbol, or empty if the game is not finished yet.
(define (game-evaluate a-game)
  (let ([evaluation (game-evaluate-triplets a-game lines-list)])
    (cond
      [(and (empty? evaluation) (game-full? a-game)) tie-symb]
      [else evaluation])))

; Evaluates the score of the game.
(define (game-score a-game)
  (let
    ([evaluation (game-evaluate a-game)])
    (cond
      [(equal? evaluation X-symb) X-score]
      [(equal? evaluation tie-symb) tie-score]
      [(empty? evaluation) ((selector-from-player (determine-next-to-play a-game)) identity (map (lambda (g) (* diminishing-factor (game-score g))) (derive-games a-game)))]
      [else O-score])))

; Returns whether or not the game has been won by a player.
(define (game-won? a-game)
  (let ([evaluation (game-evaluate a-game)])
    (or (equal? X-symb evaluation) (equal? O-symb evaluation))))

; Returns whether or not there are no more empty spaces on the board.
(define (game-full? a-game)
  (zero? (vector-count empty? (game-state a-game))))

; Returns whether or not the game is finished.
(define (game-finished? a-game)
  ; For the game to be finished, there must be a winner or no more moves left.
  (or (game-won? a-game) (game-full? a-game)))

; Returns the appropriate game score selector for a player.
(define (selector-from-player player)
  (cond
    [(equal? player X-symb) X-selector]
    [else O-selector]))

; (play Game) -> Game
;
; Plays optimally for the player who is going to play next in the game.
(define (play a-game)
  (if (not (game-finished? a-game))
    ; Return the derived game with the highest score
    ((selector-from-player (determine-next-to-play a-game)) (lambda (g) (game-score g)) (derive-games a-game))
    a-game))

; (solve Game) -> Game
;
; Solves the provided Game. This results either in a draw or a victory for
; whichever player had an advantage in the game.
(define (solve a-game)
  (if (game-finished? a-game)
    a-game
    (solve (play a-game))))

(provide vector-copy-and-replace
         game
         game-state
         game-to-string
         game-score
         game-finished?
         game-evaluate
         make-empty-game
         play
         solve)
